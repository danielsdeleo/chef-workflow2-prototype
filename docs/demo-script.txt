$ wf2 create-app demo

=> print any relevant global config
=> generate skeleton
=> tell the user what's next

$ cd demo
$ ls -R

=> What's in the skeleton?

.git/blahblahblah # autodetect if git is installed? global config for repo-initing?

Policyfile

Metalfile

cookbooks/
cookbooks/demo/
cookbooks/demo/metadata.rb
cookbooks/demo/recipes/
cookbooks/demo/recipes/default.rb


$ cat Policyfile

=> (this is the extended berksfile)

> name "demo"
>
> # which recipes to run when applying this policy to a node:
> run_list "recipe[demo::default]"
>
> # TODO: would this be in the default skeleton?
> run_list :quick_app_deploy, "recipe[demo::just_the_app_please]"
>
> # Any cookbook without an explicit source comes from here:
> default_source "https://community-api.getchef.com"
>
> # Override the source of the "demo" cookbook:
> cookbook "demo", :path => "./cookbooks"
>
> default_attributes "foo" => "bar"
> override_attributes "foo" => "baz"

$ cat Metalfile

=> default config for how dev and test VM instances are launched
=> probably defaults to vagrant, but could have commented out instructions for
   a "null" provisioner to manually managed VM or whatever.

$ wf2 converge local

=> Error: you must compile your policy with `wf2 compile` before
  converging

$ wf2 compile

> Compiling ./Policyfile
> Compiling policy "demo"
> Expanded run_list to: recipe[demo::default]
> Using cookbook "demo" version 0.1.0 from path ./cookbooks/demo
>
> Policy compiled. Use `wf2 compile` to update dependencies.

## DISCUSSION ##
# In the interest of speed (and quick dev feedback) we want to avoid
# hitting the network wherever possible. Therefore, we want to avoid
# recomputing the entire dependency solution (which may include git or
# cookbook site operations). However, we also don't want to create a
# situation where users are required to constantly type the same command
# over and over again. 
#
# Because we've chosen to generate cookbook identifiers from the content
# of the cookbooks, we need to ensure that the identifiers for on-disk
# cookbooks are updated before we upload them to the outside world or
# use the identifiers for comparison (e.g., a `diff` tool)

$ cat Policyfile.lock.json

=> See Policyfile.lock.json

$ wf2 converge local

=> run w/ chef-zero local mode.
=> should have a log/file/whatever resource that does something

$ wf2 test unit

=> chefspec

$ $EDITOR hack code

=> Make the cookbook(s) do more than just print stuff

## DISCUSSION: ##
# For demo purposes, we want to use a community cookbook here, I think.

$ wf2 compile

## DISCUSSION:##
# This step is only required if we suppose we're using a community
# cookbook, which might come a lot later in the related learnchef
# content for this tool.
#
# We also need to think about the error case here. What happens if the
# user doesn't recompile the policy?

> Compiling ./Policyfile
> Compiling policy "demo"
> Expanded run_list to: recipe[demo::default]
> Using cookbook "demo" version 0.1.0 from path ./cookbooks/demo
> Using cookbook "tmux" version 1.4.2 from https://api.community.getchef.com
>
> Policy compiled. Use `wf2 compile` to update dependencies.


$ wf2 converge development

=> default config? Vagrant?
=> vagrant isn't installed, print instructions

$ install-the-vagrant

=> vbox/vagrant/etc.

$ wf2 converge development

=> create/resume VM, run 
=> see output from chef run

$ wf2 login development

=> Get ssh session on the box
=> Do something to show the box was converged
=> exit ssh session

$ wf2 test integration

=> runs TK

$ wf2 login test

=> Get ssh session on TK box
=> poke at it to see it was converged
=> exit ssh session

$ wf2 deploy ENV_NAME (or cell name, whatever)

=> user hasn't configured any server, so prompt them to figure this out...

$ $EDITOR hack server creds

=> get client.pem, username

$ wf2 deploy ENV_NAME (or cell name, whatever)

=> compile policy to json (Policyfile.lock)
=> upload cookbooks
=> upload policy, apply to env/cell/deploy-group

##QUESTION##
what now? provision a node w/ chef-metal?
future pushy integration will be cool, not in 1.0

$ wf2 apply? $VERB 

## Possible cmds: ##

`wf2 provision`: create some nodes from Metalfile
`wf2 up/push`: just upload objects to chef server
`wf2 deploy`: figures out what nodes should get the changes, provision if necessary, do up/push, ssh-to-chef?

